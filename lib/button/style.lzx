<mixin name="stylebutton">
    <attribute name="vertical" style="gradient-vertical" value="false" type="boolean"/>
    <attribute name="bevel" style="bevel-width" value="0" type="number"/>

    <attribute name="interiorbordercolor"    value="void(0)" style="interior-border-color" type="color"/>
    <attribute name="interiorbordercolorup"    value="${this.interiorbordercolor}" style="interior-border-color-up" type="color"/>
    <attribute name="interiorbordercolorover"  value="${this.interiorbordercolor}" style="interior-border-color-over" type="color"/>
    <attribute name="interiorbordercolordown"  value="${this.interiorbordercolor}" style="interior-border-color-down" type="color"/>

    <attribute name="interiorfillcolor"      value="void(0)" style="interior-fill-color" type="color"/>
    <attribute name="interiorfillcolorup"      value="${this.interiorfillcolor}" style="interior-fill-color-up" type="color"/>
    <attribute name="interiorfillcolorover"    value="${this.interiorfillcolor}" style="interior-fill-color-over" type="color"/>
    <attribute name="interiorfillcolordown"    value="${this.interiorfillcolor}" style="interior-fill-color-down" type="color"/>

    <attribute name="gradientfillstartup"      value="void(0)" style="gradientfill-start-up" type="color"/>
    <attribute name="gradientfillstopup"       value="void(0)" style="gradientfill-stop-up" type="color"/>
    <attribute name="gradientfillstartover"    value="void(0)" style="gradientfill-start-over" type="color"/>
    <attribute name="gradientfillstopover"     value="void(0)" style="gradientfill-stop-over" type="color"/>
    <attribute name="gradientfillstartdown"    value="void(0)" style="gradientfill-start-down" type="color"/>
    <attribute name="gradientfillstopdown"     value="void(0)" style="gradientfill-stop-down" type="color"/>

    <attribute name="gradientfill" style="gradient-fill" type="string" value=""/>
    <method name="cssToLinearGradient" args="context, lineargradient">
        <![CDATA[
        // We require top|left position and percentages with colors for now...
        // linear-gradient([top | left], <color-stop>, <color-stop>[, <color-stop>]*);
        // <color-stop> stands for: <color> <percentage>
        if (! lineargradient) return;

        var cache = this._gradientfills;
        if (! cache) {
            cache = this._gradientfills = {};
        } else if (cache[lineargradient] != null) {
            return cache[lineargradient];
        }

        // From http://dev.w3.org/csswg/css3-images/#linear-gradients 
        // linear-gradient([<bg-position> || <angle>,]? <color-stop>, <color-stop>[, <color-stop>]*);
        // <color-stop> stands for: <color> [ <percentage> | <length> ]?


        var tokens = lineargradient.split(',');
        if (tokens.length < 2) {
            if ($debug) {
                Debug.warn('Gradients require a position [top | left | right | bottom] and at least two color positions', tokens, lineargradient);
            }
            return;
        }

        var startpos = tokens.shift();

//            // process angle
//            var radians = parseInt(angle);
//            // TODO: handle 'grad'
//            if (angle.indexOf('deg') == -1) {
//               radians *= (Math.PI / 180);
//            }
//
//            var radius = this.width * 4;
//            var x:Number = x + radius *Math.cos(radians);
//            var y:Number = y + radius *Math.sin(2 * Math.PI - radians);

        var xfrom=0, yfrom=0, xto = 0, yto = 0;
        if (startpos == 'top') {
            yto = this.height;
        } else if (startpos == 'bottom') {
            yfrom = this.height;
        } else if (startpos == 'left') {
            xto = this.width;
        } else if (startpos == 'right') {
            xfrom = this.width;
        } else {
            if ($debug) {
                Debug.warn('unhandled position', startpos);
            }
        }

        var g = context.createLinearGradient(xfrom,yfrom,xto,yto);
        // Add color stops
        for (var i = 0; i < tokens.length; i++) {
            var items = tokens[i].split(' ');
            var color = items[0];
            var percentage = parseInt(items[1]) * .01;
            g.addColorStop(percentage, color);
        }

        cache[lineargradient] = g;
        return g;
        ]]>
    </method>
</mixin>
