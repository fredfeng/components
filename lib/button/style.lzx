<mixin name="stylebutton">
    <attribute name="vertical" style="gradient-vertical" value="false" type="boolean"/>
    <attribute name="bevel" style="bevel-width" value="0" type="number"/>

    <attribute name="interiorbordercolor"    value="void(0)" style="interior-border-color" type="color"/>
    <attribute name="interiorbordercolorup"    value="${this.interiorbordercolor}" style="interior-border-color-up" type="color"/>
    <attribute name="interiorbordercolorover"  value="${this.interiorbordercolor}" style="interior-border-color-over" type="color"/>
    <attribute name="interiorbordercolordown"  value="${this.interiorbordercolor}" style="interior-border-color-down" type="color"/>

    <attribute name="interiorfillcolor"      value="void(0)" style="interior-fill-color" type="color"/>
    <attribute name="interiorfillcolorup"      value="${this.interiorfillcolor}" style="interior-fill-color-up" type="color"/>
    <attribute name="interiorfillcolorover"    value="${this.interiorfillcolor}" style="interior-fill-color-over" type="color"/>
    <attribute name="interiorfillcolordown"    value="${this.interiorfillcolor}" style="interior-fill-color-down" type="color"/>

    <attribute name="gradientfill" style="gradient-fill" type="string" value=""/>

    <attribute name="_parseLinearGradientCache" value="{}"/>
    <method name="parseLinearGradient" args="lineargradient">
        <![CDATA[
        var gradientschema:Object = this._parseLinearGradientCache[lineargradient];
        if (! gradientschema) {
            var tokens = lineargradient.split(',');
            if (tokens.length < 2) {
                if ($debug) {
                    Debug.warn('Gradients require a position [top | left | right | bottom] and at least two color positions', tokens, lineargradient);
                }
                return;
            }

            var startpos = tokens.shift();

//            // process angle
//            var radians = parseInt(angle);
//            // TODO: handle 'grad'
//            if (angle.indexOf('deg') == -1) {
//               radians *= (Math.PI / 180);
//            }
//
//            var radius = this.width * 4;
//            var x:Number = x + radius *Math.cos(radians);
//            var y:Number = y + radius *Math.sin(2 * Math.PI - radians);


            // create gradient schema
            gradientschema = {};
            gradientschema.startpos = startpos;
            gradientschema.colorstops = [];
            // Add color stops
            for (var i = 0; i < tokens.length; i++) {
                // color, percentage
                var items = tokens[i].split(' ');
                gradientschema.colorstops[i] = {
                                    color: items[0],
                                    percentage: parseInt(items[1]) * .01
                                };
            }
            // save to global cache
            this._parseLinearGradientCache[lineargradient] = gradientschema;
        }
        return gradientschema;
        ]]>
    </method>

    <method name="tintColor" args="color">
        if (! this._basehsv) {
            return color;
        } else {
            // Use v and s from the color
            var col = LzColorUtils.tohsv(color);
            // Use h from basecolor
            //Debug.info('tintColor', color, this._basehsv, col);
            return LzColorUtils.fromhsv(this._basehsv.h, this._basehsv.s, col.v);
        }
    </method>

    <handler name="onwidth" method="__resetgradientcache"/>
    <handler name="onheight" method="__resetgradientcache"/>
    <handler name="onbasecolor" method="__resetgradientcache"/>
    <method name="__resetgradientcache" args="ignore">
        this._gradientfills = {};
    </method>

    <method name="cssToLinearGradient" args="context, lineargradient">
        <![CDATA[
        // We require top|left position and percentages with colors for now...
        // linear-gradient([top | left], <color-stop>, <color-stop>[, <color-stop>]*);
        // <color-stop> stands for: <color> <percentage>
        if (! lineargradient) return;

        var cache = this['_gradientfills'];
        if (! cache) {
            cache = this._gradientfills = {};
        } else if (cache[lineargradient] != null) {
            return cache[lineargradient];
        }

        // From http://dev.w3.org/csswg/css3-images/#linear-gradients 
        // linear-gradient([<bg-position> || <angle>,]? <color-stop>, <color-stop>[, <color-stop>]*);
        // <color-stop> stands for: <color> [ <percentage> | <length> ]?

        var gradientschema = this.parseLinearGradient(lineargradient);

        // create gradient
        var xfrom=0, yfrom=0, xto = 0, yto = 0, startpos = gradientschema.startpos;
        if (startpos == 'top') {
            yto = this.height;
        } else if (startpos == 'bottom') {
            yfrom = this.height;
        } else if (startpos == 'left') {
            xto = this.width;
        } else if (startpos == 'right') {
            xfrom = this.width;
        } else {
            if ($debug) {
                Debug.warn('unhandled position', startpos);
            }
        }

        var g = context.createLinearGradient(xfrom,yfrom,xto,yto);
        var colorstops = gradientschema.colorstops;
        // Add color stops
        for (var i = 0, l = colorstops.length; i < l; i++) {
            var colorstop = colorstops[i];
            g.addColorStop(colorstop.percentage, this.tintColor(colorstop.color));
        }

        cache[lineargradient] = g;
        return g;
        ]]>
    </method>
</mixin>
